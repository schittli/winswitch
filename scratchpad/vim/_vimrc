set nocompatible
source $VIMRUNTIME/vimrc_example.vim
source $VIMRUNTIME/mswin.vim
behave mswin

" klvov: мои настройки
" каталог для swap-файлов
set directory=$TEMP
" start Vim in maximized window
au GUIEnter * simalt ~x
" установить keymap, чтобы по Ctrl+^ переключался на русский и обратно
set keymap=russian-jcukenwin
" по умолчанию - латинская раскладка
set iminsert=0
" по умолчанию - латинская раскладка при поиске
set imsearch=0
" игнорировать регистр при поиске
set ic
" подсвечивать поиск
set hls
" инкрементальный поиск
set is
" ширина текста
set textwidth=76 " так отформатировано на lib.ru
" минимальная высота окна пусть будет 0 (по умолчанию - 1)
set winminheight=0
" установить шрифт Consolas
set guifont=consolas:h10:cRUSSIAN
set printfont=consolas:h10:cRUSSIAN
" настраиваю для работы с русскими словами (чтобы w, b, * понимали
" русские слова)
set iskeyword=@,48-57,_,192-255
" не надо показывать панель инструментов - толку от нее нет, а место
" занимает
set go-=T
" то же для меню
set go-=m
" не надо начинать поиск с начала документа, после того, как достигнут
" конец (и наоборот)
set nowrapscan
" не надо засорять все бэкапными файлами:
set nobackup
" выключить отображение колонки фолдинга по умолчанию
set foldcolumn=0
" автоматически перечитывать файл, если он был изменен в другом приложении
set autoread

"в визуальном режиме заменять выделение содержимым регистра "", не изменяя этого регистра
"таким образом, можно несколько раз вставить один и тот же текст.
vnoremap p "_dP

" klvov: по звездочке не прыгать на следующее найденное, а просто подсветить
" старая версия - все равно может прыгать по тексту и сбивать позицию
nnoremap * *N

" выключить подсветку: пока повешу на Ctrl-F8, а вообще хочу на Ctrl-8
nnoremap <C-F8> :noh<CR>

" в визуальном режиме по команде * подсвечивать выделение
vnoremap * y :execute ":let @/=@\""<CR> :execute "set hlsearch"<CR>

" переключать на другой буфер, даже если в текущем буфере есть несохраненные изменения
set hidden

" по Alt+0 показать окно навигации по функциям
nnoremap <A-0> :TlistToggle<CR>

" по Alt-1 редактировать текущее слово
nnoremap <M-1> ciw

" по Alt-t открыть новую вкладку
nnoremap <M-t> :tabnew<CR>

"показывать только имена файлов в заголовках вкладок
set guitablabel=%t

"BEGIN БСС Северо-Запад SECTION

"установить величину отступа 2 и всегда вставлять пробелы, а не табы
set tabstop=2
set shiftwidth=2
set expandtab

nnoremap <F9> :execute SaveRunCommand()<CR><CR>

function! SaveRunCommand()
  execute ":update"
  return ":!do_nmake.cmd"
endfunction

let pascal_delphi=1

iab qfi Q.FieldByName('').AsInteger<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab qff Q.FieldByName('').AsFloat<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab qfs Q.FieldByName('').AsString<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab qfd Q.FieldByName('').AsDateTime<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab ffi Form.Fields.FieldByName('').AsInteger<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab fff Form.Fields.FieldByName('').AsFloat<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab ffs Form.Fields.FieldByName('').AsString<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab ffd Form.Fields.FieldByName('').AsDateTime<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab err Error(errTrace, cErrorDir, cModuleName, cFunctionName,<CR> '', '', 0);<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab qerr Error(errTrace, cErrorDir, cModuleName, cFunctionName,<CR> 'SQL Error', Q.LastErrorMessage, Q.LastError);
iab ift if then<CR>begin<Left><Left><Left><Left><Left><Backspace><End><CR>end;<Left><Left><Left><Left><Backspace>
iab pbs Q.ParamByName('').AsString<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab pbi Q.ParamByName('').AsInteger<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab pbf Q.ParamByName('').AsFloat<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab pbd Q.ParamByName('').AsDateTime<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab sm ShowMessage();<Left><Left>
iab mbe MessageBox(ErrMsg, LString('ST_ERROR'), mbOK or mbIconHand);
iab fndc cFunctionName : string;
iab fndf cFunctionName := '';<Left><Left>
iab ffc Form.FindComponent('')<Left><Left>
iab ff Form.Fields.
iab dd DbgTO();<Left><Left>
iab fm Fmt.Format('')<Left><Left>
iab fdoc {**<CR>  Desc here<CR>@author k.lvov<CR>@param Desc param here<CR>@return Desc return value here<CR>*}<Left><Left><Backspace><Backspace>
iab rts RecordToString()<Left>
iab pts ParamsListToString()<Left>

function! Sql2Bls() range
  for i in range(a:firstline, a:lastline)
    if i == a:firstline
      let repl = "  '" . getline(i) . " '"
    elseif i == a:lastline
      let repl = "+ '" . getline(i) . "';"
    else
      let repl = "+ '" . getline(i) . " '"
    endif
    call setline(i, repl)
  endfor
endfunction

function! Bls2Sql() range
  for i in range(a:firstline, a:lastline)
    if i == a:firstline
      let repl = substitute(getline(i), "^\\s*'\\(.*\\) '$", "\\1", "g")
    elseif i == a:lastline
      let repl = substitute(getline(i), "^\\s*+\\s\\+'\\(.*\\)';$", "\\1", "g")
    else
      let repl = substitute(getline(i), "^\\s*+\\s\\+'\\(.*\\) '$", "\\1", "g")
    endif
    call setline(i, repl)
  endfor                           	
endfunction

function! Strings2Delphi() range
  for i in range(a:firstline, a:lastline)
    let src = getline(i)
    " заменить одиночный апостроф на двойной
    let src = substitute(src, "'", "''", "g")
    if i == a:firstline
      let repl = "'" . src . "'#13#10"
    elseif i == a:lastline
      let repl = "+ '" . src . "'#13#10;"
    else
      let repl = "+ '" . src . "'#13#10"
    endif
    call setline(i, repl)
  endfor
endfunction

function! Strings2DelphiRevert() range
  for i in range(a:firstline, a:lastline)
    let src = getline(i)
    " заменить двойной апостроф на одиночный
    let src = substitute(src, "''", "'", "g")
    if i == a:firstline
      let repl = substitute(src, "^\\s*'\\(.*\\)'#13#10$", "\\1", "g")
    elseif i == a:lastline
      let repl = substitute(src, "^\\s*+\\s\\+'\\(.*\\)'#13#10;$", "\\1", "g")
    else
      let repl = substitute(src, "^\\s*+\\s\\+'\\(.*\\)'#13#10$", "\\1", "g")
    endif
    call setline(i, repl)
  endfor                           	
endfunction

vnoremap ,q :call Sql2Bls()<CR>
vnoremap ,Q :call Bls2Sql()<CR>
vnoremap ,d :call Strings2Delphi()<CR>
vnoremap ,D :call Strings2DelphiRevert()<CR>

" открыть тэг в новой вкладке
map <C-\> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>

"END БСС Северо-Запад SECTION

" Использовать сочетания клавиш для комментирования/раскомментирования визуальных блоков
vnoremap ,# :s/^/#/<CR>
vnoremap ,/ :s/^/\/\//<CR>
vnoremap ,c :s/^\/\/\\|^--\\|^> \\|^[#"%!;]//<CR>

"по F2 инвертировать значение опции 'wrap'
nnoremap <F2> :execute RotateWrap()<CR>
function! RotateWrap()
    let wrap_status = &wrap
    if wrap_status == 0
        echo "set wrap"
        return ":set wrap"
    else
        echo "set nowrap"
        return ":set nowrap"
    endif
endfunction

" по аккорду <C-Y> заменять слово под курсором на содержимое регистра "
" (при этом содержание самого регистра " не изменяется)
nnoremap <S-Y> "_diwPb
nnoremap <C-Y> yiw

" по Alt-5 изменять хвост текущего слова
nnoremap <M-5> cw

" закрывать окно плагина TagList после выбота тэга
let Tlist_Close_On_Select = 1
" не показывать тэги для неактивных буферов
let Tlist_File_Fold_Auto_Close = 1
" переходить сразу в открытое окно плагина TagList
let Tlist_GainFocus_On_ToggleOpen = 1
" использовать компактный формат списка тэгов (?)
" let Tlist_Compact_Format = 1
" уширить окно со списком тэгов, чтобы помещались длинные имена
let Tlist_WinWidth = 50

" <F12> - buffer explorer plugin
map <F12> :BufExplorer<CR>

" <F8> File encoding for open
" ucs-2le - MS Windows unicode encoding
map <F8>    :execute RotateEnc()<CR>
vmap <F8>    <C-C><F8>
imap <F8>    <C-O><F8>
function! RotateEnc()
	if !exists("b:encindex")
	  let b:encindex = 0
	endif
  let y = -1
  while y == -1
    let encstring = "#utf-8#8bit-cp866#cp1251#ucs-2le#koi8-r"
    let x = match(encstring,"#",b:encindex)
    let y = match(encstring,"#",x+1)
    let b:encindex = x+1
    if y == -1
      let b:encindex = 0
    else
      let str = strpart(encstring,x+1,y-x-1)
      silent execute ":e ++enc=".str
      echo "Screen encoding: " . &encoding . ", file encoding: " . &fileencoding
    endif
  endwhile
endfunction

set diffexpr=MyDiff()
function! MyDiff()
  let opt = '-a --binary '
  if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
  if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
  let arg1 = v:fname_in
  if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
  let arg2 = v:fname_new
  if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
  let arg3 = v:fname_out
  if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
  let eq = ''
  if $VIMRUNTIME =~ ' '
    if &sh =~ '\<cmd'
      let cmd = '""' . $VIMRUNTIME . '\diff"'
      let eq = '"'
    else
      let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
    endif
  else
    let cmd = $VIMRUNTIME . '\diff'
  endif
  silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq
endfunction

let javaScript_fold = 1